{"version":3,"sources":["../../node_modules/dirty-json/dirty-json.js","../../node_modules/dirty-json/parser.js","../../node_modules/dirty-json/lexer.js","../../node_modules/lex/lexer.js","../../node_modules/unescape-js/dist/index.js","../../node_modules/string.fromcodepoint/fromcodepoint.js","../../node_modules/utf8/utf8.js"],"names":["parser","require","module","exports","parse","text","config","fallback","duplicateKeys","e","json","JSON","console","warn","json_error","lexer","extendArray","arr","peek","Object","defineProperty","enumerable","value","this","length","last","i","is","obj","prop","hasOwnProperty","type","reduce","stack","next","pop","trim","push","middleVal","oldLastVal","qChar","single","keyValue","toPush","key","unshift","l","Error","row","col","forEach","val","stringify","v","dupKeys","tokens","lexString","t","compileOST","tree","indexOf","Array","isArray","toR","Lexer","unescapeJs","lexSpc","parseString","str","replace","emit","lex","string","addRule","lexeme","txt","parseFloat","parseInt","item","setInput","getLexer","token","getAllTokens","defunct","rules","remove","scan","matches","index","state","lastIndex","input","rule","start","states","pattern","result","exec","j","action","global","k","temple","flags","multiline","ignoreCase","RegExp","source","prototype","toString","call","shift","reject","splice","match","apply","slice","charAt","chr","default","jsEscapeRegex","usualEscapeSequences","'","fromHex","String","fromCodePoint","_","__","varHex","longHex","shortHex","octal","specialCharacter","python","undefined","object","$defineProperty","error","stringFromCharCode","fromCharCode","floor","Math","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","arguments","codePoint","Number","isFinite","RangeError","root","byteArray","byteCount","byteIndex","ucs2decode","extra","output","counter","charCodeAt","checkScalarValue","toUpperCase","createByte","encodeCodePoint","symbol","readContinuationByte","continuationByte","decodeSymbol","byte1","version","encode","codePoints","byteString","decode","tmp","array","ucs2encode"],"mappings":"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","file":"static/js/1.e1ccb33c.chunk.js","sourcesContent":["// < begin copyright > \n// Copyright Ryan Marcus 2018\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n// \n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n// \n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n// \n// < end copyright > \n \n\n\n\"use strict\";\n\nlet parser = require('./parser');\n\nmodule.exports.parse = parse;\nfunction parse(text, config) {\n    let fallback = true;\n    let duplicateKeys = false;\n\n    if (config) {\n        if ((\"fallback\" in config) && config[fallback] === false) {\n            fallback = false;\n        }\n\n        duplicateKeys = \"duplicateKeys\" in config && config[\"duplicateKeys\"] === true;\n    }\n\n    try {\n        return parser.parse(text, duplicateKeys);\n    } catch (e) {\n        // our parser threw an error! see if the JSON was valid...\n        /* istanbul ignore next */\n        if (fallback === false) {\n            throw e;\n        }\n        \n        try {\n            let json = JSON.parse(text);\n            // if we didn't throw, it was valid JSON!\n            /* istanbul ignore next */\n            console.warn(\"dirty-json got valid JSON that failed with the custom parser. We're returning the valid JSON, but please file a bug report here: https://github.com/RyanMarcus/dirty-json/issues  -- the JSON that caused the failure was: \" + text);\n\n            /* istanbul ignore next */\n            return json;\n        } catch (json_error) {\n            throw e;\n        }\n\n    }\n}\n","// < begin copyright > \n// Copyright Ryan Marcus 2018\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n// \n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n// \n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n// \n// < end copyright > \n \n\"use strict\";\n\nlet lexer = require(\"./lexer\");\n\n// terminals\nconst LEX_KV = 0;\nconst LEX_KVLIST = 1;\nconst LEX_VLIST = 2;\nconst LEX_BOOLEAN = 3;\nconst LEX_COVALUE = 4;\nconst LEX_CVALUE = 5;\nconst LEX_FLOAT = 6;\nconst LEX_INT = 7;\nconst LEX_KEY = 8;\nconst LEX_LIST = 9;\nconst LEX_OBJ = 10;\nconst LEX_QUOTE = 11;\nconst LEX_RB = 12;\nconst LEX_RCB = 13;\nconst LEX_TOKEN = 14;\nconst LEX_VALUE = 15;\n\n// non-terminals\nconst LEX_COLON = -1;\nconst LEX_COMMA = -2;\nconst LEX_LCB = -3;\nconst LEX_LB = -4;\nconst LEX_DOT = -5;\n\nfunction extendArray(arr) {\n    if (arr.peek == null) {\n        Object.defineProperty(arr, 'peek', {\n            enumerable: false,\n            value: function() {\n                return this[this.length - 1];\n            }\n        });\n    }\n    if (arr.last == null) {\n        Object.defineProperty(arr, 'last', {\n            enumerable: false,\n            value: function(i) {\n                return this[this.length - (1 + i)];\n            }\n        });\n    }\n}\n\nfunction is(obj, prop) {\n    return (obj && obj.hasOwnProperty(\"type\") && obj.type == prop);\n}\n\nfunction log(str) {\n    //console.log(str);\n}\n\n\nmodule.exports.parse = parse;\nfunction parse(text, dupKeys) {\n    let stack = [];\n\n    let tokens = [];\n\n    extendArray(stack);\n    extendArray(tokens);\n\n    let emit = function(t) {\n        tokens.push(t);\n    };\n\n    lexer.lexString(text, emit);\n\n    // ensure that if we started with a LB or LCB, we end with a\n    // RB or RCB.\n    if (tokens[0].type == LEX_LB && tokens.last(0).type != LEX_RB) {\n        tokens.push({ type: LEX_RB, value: \"]\", row: -1, col: -1});\n    }\n\n    if (tokens[0].type == LEX_LCB && tokens.last(0).type != LEX_RCB) {\n        tokens.push({ type: LEX_RCB, value: \"}\", row: -1, col: -1});\n    }\n\n    for (let i = 0; i < tokens.length; i++) {\n        log(\"Shifting \" + tokens[i].type);\n        stack.push(tokens[i]);\n        log(stack);\n        log(\"Reducing...\");\n        while (reduce(stack)) {\n            log(stack);\n            log(\"Reducing...\");\n        }\n    }\n\n    // if everything parsed into a KV list, assume it was an object missing the starting\n    // \"{\" and ending \"}\"\n    if (stack.length == 1 && stack[0].type == LEX_KVLIST) {\n        log(\"Pre-compile error fix 1\");\n        stack = [{type: LEX_OBJ, value: stack[0].value}];\n    }\n\n    return compileOST(stack[0], dupKeys);\n\n}\n\nfunction reduce(stack) {\n    let next = stack.pop();\n\n    switch(next.type) {\n    case LEX_KEY:\n        if (next.value.trim() == \"true\") {\n            log(\"Rule 5\");\n            stack.push({'type': LEX_BOOLEAN, 'value': \"true\"});\n            return true;\n        }\n\n\n        if (next.value.trim() == \"false\") {\n            log(\"Rule 6\");\n            stack.push({'type': LEX_BOOLEAN, 'value': \"false\"});\n            return true;\n        }\n\n        if (next.value.trim() == \"null\") {\n            log(\"Rule 7\");\n            stack.push({'type': LEX_VALUE, 'value': null});\n            return true;\n        }\n        break;\n\n    case LEX_TOKEN:\n        if (is(stack.peek(), LEX_KEY)) {\n            log(\"Rule 11a\");\n            stack.peek().value += next.value;\n            return true;\n        }\n\n        log(\"Rule 11c\");\n        stack.push({type: LEX_KEY, value: next.value });\n        return true;\n\n\n    case LEX_INT:\n        if (is(next, LEX_INT) && is(stack.peek(), LEX_KEY)) {\n            log(\"Rule 11b\");\n            stack.peek().value += next.value;\n            return true;\n        }\n\n        log(\"Rule 11f\");\n        next.type = LEX_VALUE;\n        stack.push(next);\n        return true;\n\n\n    case LEX_QUOTE:\n        log(\"Rule 11d\");\n        next.type = LEX_VALUE;\n        next.value = next.value;\n        stack.push(next);\n        return true;\n\n\n    case LEX_BOOLEAN:\n        log(\"Rule 11e\");\n        next.type = LEX_VALUE;\n\n        if (next.value == \"true\") {\n            next.value = true;\n        } else {\n            next.value = false;\n        }\n\n        stack.push(next);\n        return true;\n\n\n    case LEX_FLOAT:\n        log(\"Rule 11g\");\n        next.type = LEX_VALUE;\n        stack.push(next);\n        return true;\n\n    case LEX_VALUE:\n        if (is(stack.peek(), LEX_COMMA)) {\n            log(\"Rule 12\");\n            next.type = LEX_CVALUE;\n            stack.pop();\n            stack.push(next);\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_COLON)) {\n            log(\"Rule 13\");\n            next.type = LEX_COVALUE;\n            stack.pop();\n            stack.push(next);\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY) && is(stack.last(1), LEX_VALUE)) {\n            log(\"Error rule 1\");\n            let middleVal = stack.pop();\n            stack.peek().value += '\"' + middleVal.value + '\"';\n            stack.peek().value += next.value;\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY) && is(stack.last(1), LEX_VLIST)) {\n            log(\"Error rule 2\");\n            let middleVal = stack.pop();\n            let oldLastVal = stack.peek().value.pop();\n            oldLastVal +=  '\"' + middleVal.value + '\"';\n            oldLastVal += next.value;\n            \n            stack.peek().value.push(oldLastVal);\n            \n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY) && is(stack.last(1), LEX_KVLIST)) {\n            log(\"Error rule 3\");\n            let middleVal = stack.pop();\n            let oldLastVal = stack.peek().value.pop();\n            const qChar = next.single ? \"'\" : '\"';\n            \n            oldLastVal.value +=  qChar + middleVal.value + qChar;\n            oldLastVal.value += next.value;\n            \n            stack.peek().value.push(oldLastVal);\n            \n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY)) {\n            log(\"Error rule 4\");\n            let keyValue = stack.pop().value;\n            next.value = keyValue + next.value;\n            stack.push(next);\n            return true;\n        }\n\n        break;\n\n    case LEX_LIST:\n        if (is(next, LEX_LIST) && is(stack.peek(), LEX_COMMA)) {\n            log(\"Rule 12a\");\n            next.type = LEX_CVALUE;\n            stack.pop();\n            stack.push(next);\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_COLON)) {\n            log(\"Rule 13a\");\n            next.type = LEX_COVALUE;\n            stack.pop();\n            stack.push(next);\n            return true;\n        }\n        break;\n\n    case LEX_OBJ:\n        if (is(stack.peek(), LEX_COMMA)) {\n            log(\"Rule 12b\");\n            let toPush = {'type': LEX_CVALUE, 'value': next};\n            stack.pop();\n            stack.push(toPush);\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_COLON)) {\n            log(\"Rule 13b\");\n            let toPush = {'type': LEX_COVALUE, 'value': next};\n            stack.pop();\n            stack.push(toPush);\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY)) {\n            log(\"Error rule 9\");\n            let key = stack.pop();\n            stack.push({'type': LEX_KV, 'key': key.value.trim(), 'value': next});\n            return true;\n        }\n        \n        break;\n\n    case LEX_CVALUE:\n        if (is(stack.peek(), LEX_VLIST)) {\n            log(\"Rule 14\");\n            stack.peek().value.push(next.value);\n            return true;\n        }\n\n\n        log(\"Rule 15\");\n        stack.push({'type': LEX_VLIST, 'value': [next.value]});\n        return true;\n\n    case LEX_VLIST:\n        if (is(stack.peek(), LEX_VALUE)) {\n            log(\"Rule 15a\");\n            next.value.unshift(stack.peek().value);\n            stack.pop();\n            stack.push(next);\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_LIST)) {\n            log(\"Rule 15b\");\n            next.value.unshift(stack.peek().value);\n            stack.pop();\n            stack.push(next);\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_OBJ)) {\n            log(\"Rule 15c\");\n            next.value.unshift(stack.peek());\n            stack.pop();\n            stack.push(next);\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY) && (stack.last(1), LEX_COMMA)) {\n            log(\"Error rule 7\");\n            let l = stack.pop();\n            stack.push({type: LEX_VALUE, 'value': l.value});\n            log(\"Start subreduce... (\" + l.value + \")\");\n            while(reduce(stack));\n            log(\"End subreduce\");\n            stack.push(next);\n\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_VLIST)) {\n            log(\"Error rule 8\");\n            stack.peek().value.push(next.value[0]);\n            return true;\n        }\n        break;\n\n    case LEX_COVALUE:\n\n        if (is(stack.peek(), LEX_KEY) || is(stack.peek(), LEX_VALUE) || is(stack.peek(), LEX_VLIST)) {\n            log(\"Rule 16\");\n            let key = stack.pop();\n            stack.push({'type': LEX_KV, 'key': key.value, 'value': next.value});\n            return true;\n        }\n\n\n        throw new Error(\"Got a :value that can't be handled at line \" +\n                       next.row + \":\" + next.col);\n\n    case LEX_KV:\n        if (is(stack.last(0), LEX_COMMA) && is(stack.last(1), LEX_KVLIST)) {\n            log(\"Rule 17\");\n            stack.last(1).value.push(next);\n            stack.pop();\n            return true;\n        }\n\n        log(\"Rule 18\");\n        stack.push({'type': LEX_KVLIST, 'value': [next]});\n        return true;\n\n    case LEX_KVLIST:\n        if (is(stack.peek(), LEX_KVLIST)) {\n            log(\"Rule 17a\");\n            next.value.forEach(function (i) {\n                stack.peek().value.push(i);\n            });\n            return true;\n        }\n\n        break;\n\n    case LEX_RB:\n        if (is(stack.peek(), LEX_VLIST) && is(stack.last(1), LEX_LB)) {\n            log(\"Rule 19\");\n            let l = stack.pop();\n            stack.pop();\n            stack.push({'type': LEX_LIST, 'value': l.value});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_LIST) && is(stack.last(1), LEX_LB)) {\n            log(\"Rule 19b\");\n            let l = stack.pop();\n            stack.pop();\n            stack.push({'type': LEX_LIST, 'value': [l.value]});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_LB)) {\n            log(\"Rule 22\");\n            stack.pop();\n            stack.push({type: LEX_LIST, 'value': []});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_VALUE) && is(stack.last(1), LEX_LB)) {\n            log(\"Rule 23\");\n            let val = stack.pop().value;\n            stack.pop();\n            stack.push({type: LEX_LIST, 'value': [val]});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_OBJ) && is(stack.last(1), LEX_LB)) {\n            log(\"Rule 23b\");\n            let val = stack.pop();\n            stack.pop();\n            stack.push({type: LEX_LIST, 'value': [val]});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY) && is(stack.last(1), LEX_COMMA)) {\n            log(\"Error rule 5\");\n            let l = stack.pop();\n            stack.push({type: LEX_VALUE, 'value': l.value});\n            log(\"Start subreduce... (\" + l.value + \")\");\n            while(reduce(stack));\n            log(\"End subreduce\");\n            stack.push({type: LEX_RB});\n            return true;\n        }\n\n        \n        if (is(stack.peek(), LEX_COMMA) && (\n            is(stack.last(1), LEX_KEY)\n                || is(stack.last(1), LEX_OBJ)\n                || is(stack.last(1), LEX_VALUE))\n           ) {\n            log(\"Error rule 5a\");\n            stack.pop();\n            //let l = stack.pop();\n            //stack.push({type: LEX_VALUE, 'value': l.value});\n            stack.push({type: LEX_RB, 'value': ']'});\n            log(\"Start subreduce...\");\n            log(\"Content: \" + JSON.stringify(stack));\n            while(reduce(stack));\n            log(\"End subreduce\");\n\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY) && is(stack.last(1), LEX_LB)) {\n            log(\"Error rule 5b\");\n            let v = stack.pop();\n            stack.pop();\n            stack.push({type: LEX_LIST, value: [v.value]});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_COMMA) && is(stack.last(1), LEX_VLIST)) {\n            log(\"Error rule 5c\");\n            stack.pop();\n            stack.push({type: LEX_RB});\n            log(\"Start subreduce...\");\n            log(\"Content: \" + JSON.stringify(stack));\n            while(reduce(stack));\n            log(\"End subreduce\");\n\n            return true;\n        }\n\n        break;\n\n    case LEX_RCB:\n        if (is(stack.peek(), LEX_KVLIST) && is(stack.last(1), LEX_LCB)) {\n            log(\"Rule 20\");\n            let l = stack.pop();\n            stack.pop();\n            stack.push({'type': LEX_OBJ, 'value': l.value});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_LCB)) {\n            log(\"Rule 21\");\n            stack.pop();\n            stack.push({type: LEX_OBJ, 'value': null});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY) && is(stack.last(1), LEX_COLON)) {\n            log(\"Error rule 4a\");\n            let l = stack.pop();\n            stack.push({type: LEX_VALUE, 'value': l.value});\n            log(\"Start subreduce... (\" + l.value + \")\");\n            while(reduce(stack));\n            log(\"End subreduce\");\n            stack.push({type: LEX_RCB});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_COLON)) {\n            log(\"Error rule 4b\");\n            stack.push({type: LEX_VALUE, value: null});\n\n            log(\"Starting subreduce...\");\n            while (reduce(stack));\n            log(\"End subreduce.\");\n            \n            stack.push({type: LEX_RCB});\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_COMMA)) {\n            log(\"Error rule 10a\");\n            stack.pop();\n            stack.push({type: LEX_RCB});\n            return true;\n        }\n        \n        throw new Error(\"Found } that I can't handle at line \" +\n                        next.row + \":\" + next.col);\n\n        \n    case LEX_COMMA:\n        if (is(stack.peek(), LEX_COMMA)) {\n            log(\"Comma error rule 1\");\n            // do nothing -- so don't push the extra comma onto the stack\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_KEY)) {\n            log(\"Comma error rule 2\");\n            const key = stack.pop();\n            stack.push({type: LEX_VALUE, value: key.value});\n            \n            log(\"Starting subreduce...\");\n            while (reduce(stack));\n            log (\"End subreduce.\");\n            \n            stack.push(next);\n            return true;\n        }\n\n        if (is(stack.peek(), LEX_COLON)) {\n            log(\"Comma error rule 3\");\n            stack.push({type: LEX_VALUE, value: null});\n            \n            log(\"Starting subreduce...\");\n            while (reduce(stack));\n            log (\"End subreduce.\");\n            \n            stack.push(next);\n            return true;\n        }\n\n    }\n\n\n    stack.push(next);\n    return false;\n}\n\n\n\nfunction compileOST(tree, dupKeys) {\n    let rawTypes = [\"boolean\", \"number\", \"string\"];\n\n    if (rawTypes.indexOf((typeof tree)) != -1)\n        return tree;\n\n    if (tree === null)\n        return null;\n\n    if (Array.isArray(tree)) {\n        let toR = [];\n        while (tree.length > 0)\n            toR.unshift(compileOST(tree.pop()));\n        return toR;\n    }\n    \n\n    if (is(tree, LEX_OBJ)) {\n        let toR = {};\n        if (tree.value === null)\n            return {};\n        tree.value.forEach(function (i) {\n            const key = i.key;\n            const val = compileOST(i.value);\n\n            if (dupKeys && key in toR) {\n                toR[key] = {\n                    \"value\": toR[key],\n                    \"next\": val\n                };\n            } else {\n                toR[key] = val;\n            }\n        });\n        return toR;\n    }\n\n    if (is(tree, LEX_LIST)) {\n        return compileOST(tree.value);\n    }\n\n    // it must be a value\n    return tree.value;\n}\n\n","// < begin copyright > \n// Copyright Ryan Marcus 2018\n// \n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n// \n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n// \n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n// \n// < end copyright > \n \n\"use strict\";\n\nconst Lexer = require(\"lex\");\nconst unescapeJs = require(\"unescape-js\");\nconst utf8 = require(\"utf8\");\n\n// terminals\nconst LEX_KV = 0;\nconst LEX_KVLIST = 1;\nconst LEX_VLIST = 2;\nconst LEX_BOOLEAN = 3;\nconst LEX_COVALUE = 4;\nconst LEX_CVALUE = 5;\nconst LEX_FLOAT = 6;\nconst LEX_INT = 7;\nconst LEX_KEY = 8;\nconst LEX_LIST = 9;\nconst LEX_OBJ = 10;\nconst LEX_QUOTE = 11;\nconst LEX_RB = 12;\nconst LEX_RCB = 13;\nconst LEX_TOKEN = 14;\nconst LEX_VALUE = 15;\n\n// non-terminals\nconst LEX_COLON = -1;\nconst LEX_COMMA = -2;\nconst LEX_LCB = -3;\nconst LEX_LB = -4;\nconst LEX_DOT = -5;\n\n\nconst lexMap = {\n    \":\": {type: LEX_COLON},\n    \",\": {type: LEX_COMMA},\n    \"{\": {type: LEX_LCB},\n    \"}\": {type: LEX_RCB},\n    \"[\": {type: LEX_LB},\n    \"]\": {type: LEX_RB},\n    \".\": {type: LEX_DOT} // TODO: remove?\n};\n\nconst lexSpc = [\n    [/\\s*:\\s*/, LEX_COLON],\n    [/\\s*,\\s*/, LEX_COMMA],\n    [/\\s*{\\s*/, LEX_LCB],\n    [/\\s*}\\s*/, LEX_RCB],\n    [/\\s*\\[\\s*/, LEX_LB],\n    [/\\s*\\]\\s*/, LEX_RB],\n    [/\\s*\\.\\s*/, LEX_DOT] // TODO: remove?\n];\n\nfunction parseString(str) {\n    // unescape-js doesn't cover the \\/ case, but we will here.\n    str = str.replace(/\\\\\\//, '/');\n    return unescapeJs(str);\n}\n\n\nfunction getLexer(string) {\n    let lexer = new Lexer();\n\n    let col = 0;\n    let row = 0;\n    \n    lexer.addRule(/\"((?:\\\\.|[^\"])*?)($|\")/, (lexeme, txt) => {\n        col += lexeme.length;\n        return {type: LEX_QUOTE, value: parseString(txt), row, col, single: false};\n    });\n\n    lexer.addRule(/'((?:\\\\.|[^'])*?)($|'|(\",?[ \\t]*\\n))/, (lexeme, txt) => {\n        col += lexeme.length;\n        return {type: LEX_QUOTE, value: parseString(txt), row, col, single: true};\n    });\n\n    // floats with a dot\n    lexer.addRule(/[\\-0-9]*\\.[0-9]*([eE][\\+\\-]?)?[0-9]*(?:\\s*)/, lexeme => {\n        col += lexeme.length;\n        return {type: LEX_FLOAT, value: parseFloat(lexeme), row, col};\n    });\n\n    // floats without a dot but with e notation\n    lexer.addRule(/\\-?[0-9]+([eE][\\+\\-]?)[0-9]*(?:\\s*)/, lexeme => {\n        col += lexeme.length;\n        return {type: LEX_FLOAT, value: parseFloat(lexeme), row, col};\n    });\n    \n    lexer.addRule(/\\-?[0-9]+(?:\\s*)/, lexeme => {\n        col += lexeme.length;\n        return {type: LEX_INT, value: parseInt(lexeme), row, col};\n    });\n\n    lexSpc.forEach(item => {\n        lexer.addRule(item[0], lexeme => {\n            col += lexeme.length;\n            return {type: item[1], value: lexeme, row, col};\n        });\n    });\n\n    lexer.addRule(/\\s/, lexeme => {\n        // chomp whitespace...\n        if (lexeme == \"\\n\") {\n            col = 0;\n            row++;\n        } else {\n            col += lexeme.length;\n        }\n    });\n\n    \n    lexer.addRule(/\\S[ \\t]*/, lexeme => {\n        col += lexeme.length;\n        \n        let lt = LEX_TOKEN;\n        let val = lexeme;\n        \n        return {type: lt, value: val, row, col};\n    });\n    \n\n\n\n    lexer.setInput(string);\n\n    return lexer;\n}\n\n\n\nmodule.exports.lexString = lexString;\nfunction lexString(str, emit) {\n    let lex = getLexer(str);\n\n    let token = \"\";\n    while ((token = lex.lex())) {\n        emit(token);\n    }\n    \n}\n\nmodule.exports.getAllTokens = getAllTokens;\nfunction getAllTokens(str) {\n    let arr = [];\n    let emit = function (i) {\n        arr.push(i);\n    };\n\n    lexString(str, emit);\n\n    return arr;\n}\n\n\n\n","if (typeof module === \"object\" && typeof module.exports === \"object\") module.exports = Lexer;\n\nLexer.defunct = function (chr) {\n    throw new Error(\"Unexpected character at index \" + (this.index - 1) + \": \" + chr);\n};\n\nfunction Lexer(defunct) {\n    if (typeof defunct !== \"function\") defunct = Lexer.defunct;\n\n    var tokens = [];\n    var rules = [];\n    var remove = 0;\n    this.state = 0;\n    this.index = 0;\n    this.input = \"\";\n\n    this.addRule = function (pattern, action, start) {\n        var global = pattern.global;\n\n        if (!global) {\n            var flags = \"g\";\n            if (pattern.multiline) flags += \"m\";\n            if (pattern.ignoreCase) flags += \"i\";\n            pattern = new RegExp(pattern.source, flags);\n        }\n\n        if (Object.prototype.toString.call(start) !== \"[object Array]\") start = [0];\n\n        rules.push({\n            pattern: pattern,\n            global: global,\n            action: action,\n            start: start\n        });\n\n        return this;\n    };\n\n    this.setInput = function (input) {\n        remove = 0;\n        this.state = 0;\n        this.index = 0;\n        tokens.length = 0;\n        this.input = input;\n        return this;\n    };\n\n    this.lex = function () {\n        if (tokens.length) return tokens.shift();\n\n        this.reject = true;\n\n        while (this.index <= this.input.length) {\n            var matches = scan.call(this).splice(remove);\n            var index = this.index;\n\n            while (matches.length) {\n                if (this.reject) {\n                    var match = matches.shift();\n                    var result = match.result;\n                    var length = match.length;\n                    this.index += length;\n                    this.reject = false;\n                    remove++;\n\n                    var token = match.action.apply(this, result);\n                    if (this.reject) this.index = result.index;\n                    else if (typeof token !== \"undefined\") {\n                        switch (Object.prototype.toString.call(token)) {\n                        case \"[object Array]\":\n                            tokens = token.slice(1);\n                            token = token[0];\n                        default:\n                            if (length) remove = 0;\n                            return token;\n                        }\n                    }\n                } else break;\n            }\n\n            var input = this.input;\n\n            if (index < input.length) {\n                if (this.reject) {\n                    remove = 0;\n                    var token = defunct.call(this, input.charAt(this.index++));\n                    if (typeof token !== \"undefined\") {\n                        if (Object.prototype.toString.call(token) === \"[object Array]\") {\n                            tokens = token.slice(1);\n                            return token[0];\n                        } else return token;\n                    }\n                } else {\n                    if (this.index !== index) remove = 0;\n                    this.reject = true;\n                }\n            } else if (matches.length)\n                this.reject = true;\n            else break;\n        }\n    };\n\n    function scan() {\n        var matches = [];\n        var index = 0;\n\n        var state = this.state;\n        var lastIndex = this.index;\n        var input = this.input;\n\n        for (var i = 0, length = rules.length; i < length; i++) {\n            var rule = rules[i];\n            var start = rule.start;\n            var states = start.length;\n\n            if ((!states || start.indexOf(state) >= 0) ||\n                (state % 2 && states === 1 && !start[0])) {\n                var pattern = rule.pattern;\n                pattern.lastIndex = lastIndex;\n                var result = pattern.exec(input);\n\n                if (result && result.index === lastIndex) {\n                    var j = matches.push({\n                        result: result,\n                        action: rule.action,\n                        length: result[0].length\n                    });\n\n                    if (rule.global) index = j;\n\n                    while (--j > index) {\n                        var k = j - 1;\n\n                        if (matches[j].length > matches[k].length) {\n                            var temple = matches[j];\n                            matches[j] = matches[k];\n                            matches[k] = temple;\n                        }\n                    }\n                }\n            }\n        }\n\n        return matches;\n    }\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nrequire(\"string.fromcodepoint\");\n\n/**\n * \\\\ - matches the backslash which indicates the beginning of an escape sequence\n * (\n *   u\\{([0-9A-Fa-f]+)\\} - first alternative; matches the variable-length hexadecimal escape sequence (\\u{ABCD0})\n * |\n *   u([0-9A-Fa-f]{4}) - second alternative; matches the 4-digit hexadecimal escape sequence (\\uABCD)\n * |\n *   x([0-9A-Fa-f]{2}) - third alternative; matches the 2-digit hexadecimal escape sequence (\\xA5)\n * |\n *   ([1-7][0-7]{0,2}|[0-7]{2,3}) - fourth alternative; matches the up-to-3-digit octal escape sequence (\\5 or \\512)\n * |\n *   (['\"tbrnfv0\\\\]) - fifth alternative; matches the special escape characters (\\t, \\n and so on)\n * |\n *   \\U([0-9A-Fa-f]+) - sixth alternative; matches the 8-digit hexadecimal escape sequence used by python (\\U0001F3B5)\n * )\n */\nvar jsEscapeRegex = /\\\\(u\\{([0-9A-Fa-f]+)\\}|u([0-9A-Fa-f]{4})|x([0-9A-Fa-f]{2})|([1-7][0-7]{0,2}|[0-7]{2,3})|(['\"tbrnfv0\\\\]))|\\\\U([0-9A-Fa-f]{8})/g;\nvar usualEscapeSequences = {\n  '0': '\\0',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'v': '\\v',\n  '\\'': '\\'',\n  '\"': '\"',\n  '\\\\': '\\\\'\n};\n\nvar fromHex = function fromHex(str) {\n  return String.fromCodePoint(parseInt(str, 16));\n};\n\nvar fromOct = function fromOct(str) {\n  return String.fromCodePoint(parseInt(str, 8));\n};\n\nvar _default = function _default(string) {\n  return string.replace(jsEscapeRegex, function (_, __, varHex, longHex, shortHex, octal, specialCharacter, python) {\n    if (varHex !== undefined) {\n      return fromHex(varHex);\n    } else if (longHex !== undefined) {\n      return fromHex(longHex);\n    } else if (shortHex !== undefined) {\n      return fromHex(shortHex);\n    } else if (octal !== undefined) {\n      return fromOct(octal);\n    } else if (python !== undefined) {\n      return fromHex(python);\n    } else {\n      return usualEscapeSequences[specialCharacter];\n    }\n  });\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (!String.fromCodePoint) {\n\t(function() {\n\t\tvar defineProperty = (function() {\n\t\t\t// IE 8 only supports `Object.defineProperty` on DOM elements\n\t\t\ttry {\n\t\t\t\tvar object = {};\n\t\t\t\tvar $defineProperty = Object.defineProperty;\n\t\t\t\tvar result = $defineProperty(object, object, object) && $defineProperty;\n\t\t\t} catch(error) {}\n\t\t\treturn result;\n\t\t}());\n\t\tvar stringFromCharCode = String.fromCharCode;\n\t\tvar floor = Math.floor;\n\t\tvar fromCodePoint = function(_) {\n\t\t\tvar MAX_SIZE = 0x4000;\n\t\t\tvar codeUnits = [];\n\t\t\tvar highSurrogate;\n\t\t\tvar lowSurrogate;\n\t\t\tvar index = -1;\n\t\t\tvar length = arguments.length;\n\t\t\tif (!length) {\n\t\t\t\treturn '';\n\t\t\t}\n\t\t\tvar result = '';\n\t\t\twhile (++index < length) {\n\t\t\t\tvar codePoint = Number(arguments[index]);\n\t\t\t\tif (\n\t\t\t\t\t!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n\t\t\t\t\tcodePoint < 0 || // not a valid Unicode code point\n\t\t\t\t\tcodePoint > 0x10FFFF || // not a valid Unicode code point\n\t\t\t\t\tfloor(codePoint) != codePoint // not an integer\n\t\t\t\t) {\n\t\t\t\t\tthrow RangeError('Invalid code point: ' + codePoint);\n\t\t\t\t}\n\t\t\t\tif (codePoint <= 0xFFFF) { // BMP code point\n\t\t\t\t\tcodeUnits.push(codePoint);\n\t\t\t\t} else { // Astral code point; split in surrogate halves\n\t\t\t\t\t// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\t\tcodePoint -= 0x10000;\n\t\t\t\t\thighSurrogate = (codePoint >> 10) + 0xD800;\n\t\t\t\t\tlowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t\t\t\t\tcodeUnits.push(highSurrogate, lowSurrogate);\n\t\t\t\t}\n\t\t\t\tif (index + 1 == length || codeUnits.length > MAX_SIZE) {\n\t\t\t\t\tresult += stringFromCharCode.apply(null, codeUnits);\n\t\t\t\t\tcodeUnits.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tif (defineProperty) {\n\t\t\tdefineProperty(String, 'fromCodePoint', {\n\t\t\t\t'value': fromCodePoint,\n\t\t\t\t'configurable': true,\n\t\t\t\t'writable': true\n\t\t\t});\n\t\t} else {\n\t\t\tString.fromCodePoint = fromCodePoint;\n\t\t}\n\t}());\n}\n","/*! https://mths.be/utf8js v3.0.0 by @mathias */\n;(function(root) {\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tcheckScalarValue(codePoint);\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\troot.version = '3.0.0';\n\troot.encode = utf8encode;\n\troot.decode = utf8decode;\n\n}(typeof exports === 'undefined' ? this.utf8 = {} : exports));\n"],"sourceRoot":""}